import{R as b,b as E,c as A}from"./state-BMzes8HB.js";import{A as g}from"./sdk-_0emOJGD.js";import{s as O}from"./index-fJAnoxGC.js";import{r as l}from"./vendor-B6OAZll8.js";import{t as y}from"./utils-E4Pq5uL6.js";const N=b({key:"connectionState",default:{accessToken:null,isConnected:!1,isStreaming:!1,isConnecting:!1,currentApiKey:"",currentBaseUrl:void 0,currentFlowId:void 0,currentSessionId:void 0,error:void 0}});let e=null,I,k;function S(n){const o=n.environment;return console.log("getCurrentSettings",{env:o,settings:n}),{apiKey:n[o].connection.apiKey,baseUrl:n[o].connection.baseUrl,authBaseUrl:n[o].connection.authBaseUrl,workflowId:n[o].connection.workflowId,environment:o,stt:n[o].stt,tts:n[o].tts}}function P(){const[n,o]=E(N),d=A(O);l.useEffect(()=>{const r=n.currentSessionId;r&&r!==I?(y.success("Connection established successfully",{description:`Session: ${r.substring(0,16)}...`}),I=r):!r&&I&&(y.error("Connection lost",{description:"Session has been terminated"}),I=void 0)},[n.currentSessionId]),l.useEffect(()=>{n.error&&n.error!==k?(y.error("Connection Error",{description:n.error}),k=n.error):!n.error&&k&&(k=void 0)},[n.error]);const f=l.useCallback(async(r=!1)=>{const u=S(d),{apiKey:s,baseUrl:a,authBaseUrl:c,workflowId:i,environment:w}=u;if(!s)throw new Error("API key is required");if(w==="dev"&&!i)throw new Error("Workflow ID is required for development environment");if(r||!e||e.apiKey!==s||e.baseUrl!==a||e.authBaseUrl!==c||e.workflowId!==i||e.environment!==w){if(console.log("useConnection closing existing session: ",e),e)try{await g.closeSession(e.accessToken,{apiKey:e.apiKey,authBaseUrl:e.authBaseUrl,workflowId:e.workflowId})}catch{}o(t=>({...t,isConnecting:!0,error:void 0}));try{console.log("useConnection creating new access token",{apiKey:s,authBaseUrl:c,workflowId:i||void 0});const{accessToken:t}=await g.grantToken({apiKey:s,authBaseUrl:c,workflowId:i||void 0}),C=new g({accessToken:t,baseUrl:a,authBaseUrl:c,workflowId:i||void 0});let v;return t&&(v=t),e={client:C,accessToken:t,apiKey:s,baseUrl:a,authBaseUrl:c,workflowId:i,environment:w,sessionId:v},o(K=>({...K,accessToken:t,currentApiKey:s,currentBaseUrl:a,currentSessionId:v,isConnected:!0,isConnecting:!1,error:void 0})),C}catch(t){throw o(C=>({...C,isConnecting:!1,error:t instanceof Error?t.message:String(t)})),t}}return e.client},[d,o]);l.useEffect(()=>{const r=S(d),{apiKey:u,baseUrl:s,authBaseUrl:a,workflowId:c,environment:i}=r;e&&n.isConnected&&(e.apiKey!==u||e.baseUrl!==s||e.authBaseUrl!==a||e.workflowId!==c||e.environment!==i)&&(console.log("useConnection: Connection settings changed, recreating client",{oldApiKey:e.apiKey,newApiKey:u,oldBaseUrl:e.baseUrl,newBaseUrl:s,oldAuthBaseUrl:e.authBaseUrl,newAuthBaseUrl:a,oldWorkflowId:e.workflowId,newWorkflowId:c,oldEnvironment:e.environment,newEnvironment:i}),f(!0).catch(m=>{console.error("Failed to recreate client after settings change:",m)}))},[d,n.isConnected,f]);const h=l.useCallback(async(r=!1)=>{await f(r)},[f]),U=l.useCallback(async()=>{if(e){try{await g.closeSession(e.accessToken,{apiKey:e.apiKey,authBaseUrl:e.authBaseUrl,workflowId:e.workflowId})}catch{}e=null}o({accessToken:null,isConnected:!1,isStreaming:!1,isConnecting:!1,currentApiKey:"",currentBaseUrl:void 0,currentFlowId:void 0,currentSessionId:void 0,error:void 0})},[o]),p=(()=>{if(n.error)return{isOnline:!1,status:"error",reason:n.error};const r=S(d);return!r.apiKey||r.apiKey.trim().length===0?{isOnline:!1,status:"Offline",reason:"No API key configured"}:n.isConnecting?{isOnline:!1,status:"Connecting",reason:"Establishing connection..."}:n.isConnected?{isOnline:!0,status:"Ready",reason:"Connected"}:{isOnline:!1,status:"Offline",reason:"Ready to connect"}})(),B=l.useCallback(r=>{o(u=>({...u,...r}))},[o]);return{isConnected:n.isConnected,sessionId:n.currentSessionId,error:n.error,isStreaming:n.isStreaming,isConnecting:n.isConnecting,currentFlowId:n.currentFlowId,isOnline:p.isOnline,status:p.status,reason:p.reason,getClient:f,createSession:h,disconnect:U,updateConnectionState:B}}export{P as u};
