import{R as b,b as E,c as A}from"./state-BMzes8HB.js";import{A as g}from"./sdk-9Bd1H_oq.js";import{s as O}from"./index-CeHcYKT_.js";import{r as u}from"./vendor-B6OAZll8.js";import{t as y}from"./utils-E4Pq5uL6.js";const N=b({key:"connectionState",default:{accessToken:null,isConnected:!1,isStreaming:!1,isConnecting:!1,currentApiKey:"",currentBaseUrl:void 0,currentFlowId:void 0,currentSessionId:void 0,error:void 0}});let e=null,I,v;function S(n){const o=n.environment;return console.log("getCurrentSettings",{env:o,settings:n}),{apiKey:n[o].connection.apiKey,baseUrl:n[o].connection.baseUrl,authBaseUrl:n[o].connection.authBaseUrl,workflowId:n[o].connection.workflowId,environment:o,stt:n[o].stt,tts:n[o].tts}}function P(){const[n,o]=E(N),f=A(O);u.useEffect(()=>{const r=n.currentSessionId;r&&r!==I?(y.success("Connection established successfully",{description:`Session: ${r.substring(0,16)}...`}),I=r):!r&&I&&(y.error("Connection lost",{description:"Session has been terminated"}),I=void 0)},[n.currentSessionId]),u.useEffect(()=>{n.error&&n.error!==v?(y.error("Connection Error",{description:n.error}),v=n.error):!n.error&&v&&(v=void 0)},[n.error]);const w=u.useCallback(async(r=!1)=>{const d=S(f),{apiKey:s,baseUrl:a,authBaseUrl:c,workflowId:i,environment:l}=d;if(!s)throw new Error("API key is required");if(l==="dev"&&!i)throw new Error("Workflow ID is required for development environment");if(r||!e||e.apiKey!==s||e.baseUrl!==a||e.authBaseUrl!==c||e.workflowId!==i||e.environment!==l){if(console.log("useConnection closing existing session: ",e),e)try{await g.closeSession(e.accessToken,{apiKey:e.apiKey,authBaseUrl:e.authBaseUrl,workflowId:e.workflowId})}catch{}o(t=>({...t,isConnecting:!0,error:void 0}));try{console.log("useConnection creating new access token",{apiKey:s,authBaseUrl:c,workflowId:l==="dev"?i:void 0});const{accessToken:t}=await g.grantToken({apiKey:s,authBaseUrl:c,workflowId:l==="dev"?i:void 0}),C=new g({accessToken:t,baseUrl:a,authBaseUrl:c,workflowId:l==="dev"?i:null});let p;return t&&(p=t),e={client:C,accessToken:t,apiKey:s,baseUrl:a,authBaseUrl:c,workflowId:i,environment:l,sessionId:p},o(K=>({...K,accessToken:t,currentApiKey:s,currentBaseUrl:a,currentSessionId:p,isConnected:!0,isConnecting:!1,error:void 0})),C}catch(t){throw o(C=>({...C,isConnecting:!1,error:t instanceof Error?t.message:String(t)})),t}}return e.client},[f,o]);u.useEffect(()=>{const r=S(f),{apiKey:d,baseUrl:s,authBaseUrl:a,workflowId:c,environment:i}=r;e&&n.isConnected&&(e.apiKey!==d||e.baseUrl!==s||e.authBaseUrl!==a||e.workflowId!==c||e.environment!==i)&&(console.log("useConnection: Connection settings changed, recreating client",{oldApiKey:e.apiKey,newApiKey:d,oldBaseUrl:e.baseUrl,newBaseUrl:s,oldAuthBaseUrl:e.authBaseUrl,newAuthBaseUrl:a,oldWorkflowId:e.workflowId,newWorkflowId:c,oldEnvironment:e.environment,newEnvironment:i}),w(!0).catch(m=>{console.error("Failed to recreate client after settings change:",m)}))},[f,n.isConnected,w]);const h=u.useCallback(async(r=!1)=>{await w(r)},[w]),U=u.useCallback(async()=>{if(e){try{await g.closeSession(e.accessToken,{apiKey:e.apiKey,authBaseUrl:e.authBaseUrl,workflowId:e.workflowId})}catch{}e=null}o({accessToken:null,isConnected:!1,isStreaming:!1,isConnecting:!1,currentApiKey:"",currentBaseUrl:void 0,currentFlowId:void 0,currentSessionId:void 0,error:void 0})},[o]),k=(()=>{if(n.error)return{isOnline:!1,status:"error",reason:n.error};const r=S(f);return!r.apiKey||r.apiKey.trim().length===0?{isOnline:!1,status:"Offline",reason:"No API key configured"}:n.isConnecting?{isOnline:!1,status:"Connecting",reason:"Establishing connection..."}:n.isConnected?{isOnline:!0,status:"Ready",reason:"Connected"}:{isOnline:!1,status:"Offline",reason:"Ready to connect"}})(),B=u.useCallback(r=>{o(d=>({...d,...r}))},[o]);return{isConnected:n.isConnected,sessionId:n.currentSessionId,error:n.error,isStreaming:n.isStreaming,isConnecting:n.isConnecting,currentFlowId:n.currentFlowId,isOnline:k.isOnline,status:k.status,reason:k.reason,getClient:w,createSession:h,disconnect:U,updateConnectionState:B}}export{P as u};
